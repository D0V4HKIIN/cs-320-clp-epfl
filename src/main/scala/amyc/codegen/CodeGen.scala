package amyc
package codegen

import analyzer._
import amyc.ast.Identifier
import amyc.ast.SymbolicTreeModule.{
  Call => AmyCall,
  Div => AmyDiv,
  And => AmyAnd,
  Or => AmyOr,
  _
}
import amyc.utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
// compile with run library/Std.amy [file]
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect {
        case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
          cgFunction(fd, name, false)
      } ++
        // Generate code for the "main" function, which contains the module expression
        optExpr.toList.map { expr =>
          val mainFd =
            FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
          cgFunction(mainFd, name, true)
        }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain) { lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        val comment = Comment(fd.toString)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
          // so we need to drop the value generated by their body
        } else {
          comment <:> body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(
        expr: Expr
    )(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        // Literals
        case IntLiteral(i) =>
          // Push i to the stack.
          // The comments are optional but can help you debug.
          Comment(expr.toString) <:> Const(i)

        case BooleanLiteral(b) =>
          // Push b 1 or 0 to the stack
          if (b) then Comment(expr.toString) <:> Const(1)
          else Comment(expr.toString) <:> Const(0)

        case StringLiteral(s) => mkString(s) // already adds a comment

        case UnitLiteral() => Comment(expr.toString) <:> Const(0)

        // Variables
        // pushes the local (variable) to the stack
        case Variable(v) => Comment(expr.toString) <:> GetLocal(locals(v))

        // Binary operators
        case Plus(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Add
        case Minus(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Sub
        case Times(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Mul
        // see top of file at import
        // division by 0??
        case AmyDiv(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Div
        case Mod(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Rem
        case LessThan(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Lt_s
        case LessEquals(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Le_s

        // lh && rh
        // ==  if(lh) then rh
        //     else false
        case AmyAnd(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> If_i32 <:> cgExpr(e2) <:> Else <:> Const(0) <:> End
        case AmyOr(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(e2) <:> End
        case Equals(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:> cgExpr(e2) <:> Eq
        // call the string concat function
        case Concat(e1, e2) =>
          Comment(expr.toString) <:> cgExpr(e1) <:>
            cgExpr(e2) <:> Call("String_concat")

        // equals zero bc 1 => 0 and 0 => 1
        case Not(e) => Comment(expr.toString) <:> Comment("not") <:> cgExpr(e) <:> Eqz <:> Comment("end of not")
        // multiply by -1
        case Neg(e) =>
          Comment(expr.toString) <:> cgExpr(e) <:> Const(-1) <:> Mul

        // foldLeft to push all args to the stack
        // reverse because i prepend in foldLeft but we want the first arg to be the first added to the stack
        // might be wrong
        case AmyCall(qname, args) =>
          table.getConstructor(qname) match {
            case Some(conSig) => // constructor call
              val addr = lh.getFreshLocal()
              val argsCode: List[Code] = (args.map(arg => cgExpr(arg)) zip (1 to args.size)).map(argsCode =>
                GetLocal(addr) <:> Const(4 * argsCode._2) <:> Add <:> argsCode._1 <:> Store)

              Comment(expr.toString) <:> Comment("store constructor id to the memory boundary") <:> 
              GetGlobal(memoryBoundary) <:> SetLocal(addr) <:> 
              Comment("update memboundary (constr)") <:> GetGlobal(memoryBoundary) <:> Const(4 * (args.size + 1)) <:> Add <:>
              SetGlobal(memoryBoundary) <:> Comment("save the adress") <:> GetLocal(addr) <:> Const(conSig.index) <:>
              Store <:> Comment("put arguments after the id") <:> argsCode <:> 
              // put the pointer of the class to the stack (addr)
              Comment("put the pointer of the class to the stack (addr)") <:> GetLocal(addr)


            case None => // function call
              // args.map(arg => cgExpr(arg)) <:> Call(Utils.fullName(table.getFunction(qname).get.owner, qname))
              Comment(expr.toString) <:> args.foldLeft(List[Code]()) { case (acc, e) => cgExpr(e) :: acc }.reverse <:> 
              Call(fullName(table.getFunction(qname).get.owner, qname))

            // case _ => {throw new Exception("bruh dude, dis call ain't good")}
            // This case is unreachable except for null, so we can ommit it
          }  


        // generate code for left and right side. drop what e1 generated because it is not being consumed
        case Sequence(e1, e2) =>
          Comment(e1.toString) <:> cgExpr(e1) <:> Drop <:> Comment(e2.toString) <:> cgExpr(e2)

        // push value to stack
        // set fresh local
        // generate code for the following code with new locals
        case Let(paramDef, value, body) =>
          val fresh = lh.getFreshLocal()
          Comment(expr.toString) <:> cgExpr(value) <:>
          SetLocal(fresh) <:>
          cgExpr(body)(locals + (paramDef.name -> fresh), lh)

        // push condition boolean to stack
        // if
        // then code
        // else
        // else code
        // end
        case Ite(condition, thenn, elze) =>
          Comment(expr.toString) <:> cgExpr(condition) <:>
          If_i32 <:> cgExpr(thenn) <:>
          Else <:> cgExpr(elze) <:>
          End


        // Checks if a value matches a pattern.
        // Assumes value is on top of stack (and CONSUMES it)
        // Returns the code to check the value, and a map of bindings.
        
        case Match(scrut, cases) =>
          // eval scrut
          // put in a local
          val scrutLocal = lh.getFreshLocal()
          val scrutCode: Code = cgExpr(scrut) <:> SetLocal(scrutLocal)

          // needs to be put onto the stack every time matchAndBind is called

          def matchAndBind(resultCode: Code, pat: Pattern): (Code, Map[Identifier, Int]) = {
            pat match {
              // wildcard pattern is always true. drop assumes scrut on stack
              // We cannot pass Map.empty bc it might create a NoSuchElementException when key not found. Instead we use locals
              case WildcardPattern() => (Comment(pat.toString) <:> resultCode <:> Drop <:> Const(1),  locals) 
              
              // get literal, compare equality
              case LiteralPattern(lit) => (Comment(pat.toString) <:> resultCode <:> cgExpr(lit) <:> Eq, locals)


              case IdPattern(id) =>
                val idLocal = lh.getFreshLocal()
                (Comment(pat.toString) <:>
                    // get scrutlocal because we do it on a per match case, bc wildcard doesn't need it
                    // Assign val to id, after the resultCode.
                    Comment("set idLocal") <:>
                    (resultCode <:> SetLocal(idLocal)) <:>
                    // Return true (IdPattern always matches).
                    Const(1),
                    // Let the code generation of the expression which corresponds to this pattern
                    // know that the bound id is at local idLocal.
                    Map(id -> idLocal))

              // [scrut pointer] stack
              // load
              // [scrutid] stack
              // push pattern case class id to the stack (Const)
              // [scrutid, patterncaseclassid] stack
              // Eq
              // And matchAndBind(args...) (probably be done outside)
              // map args

              case CaseClassPattern(constr, args) =>
                val constrIndex = lh.getFreshLocal()
                val index = table.getConstructor(constr).get.index
                val argsAndNewLocalsCodes = args.zipWithIndex.map(pair =>
                  matchAndBind(GetLocal(constrIndex) <:> Utils.adtField(pair._2) <:> Load, pair._1))
                val argCode: Code = {
                  if (args.isEmpty) Const(1)
                  else if (args.lengthCompare(1) == 0) argsAndNewLocalsCodes.map(_._1)
                  else argsAndNewLocalsCodes.map(_._1) <:> args.tail.map(arg => And)
                }
                val caseClassCode: Code =
                  resultCode <:> SetLocal(constrIndex) <:> GetLocal(constrIndex) <:> Load <:>
                    Const(index) <:> Eq <:> If_i32 <:> argCode <:> Else <:> Const(0) <:> End
                val newLocals = locals ++ argsAndNewLocalsCodes.map(_._2).foldLeft(Map[Identifier,
                    Int]())((m1: Map[Identifier, Int], m2: Map[Identifier, Int]) => m1 ++ m2)
                (caseClassCode, newLocals)
            }
          }
          val caseCodeMapping: List[(MatchCase, (Code, Map[Identifier, Int]))] = cases.map(cse =>
            (cse, matchAndBind(GetLocal(scrutLocal), cse.pat)))
          val caseCodes = caseCodeMapping.map(pair => pair._2._1 <:> If_i32 <:> cgExpr(pair._1.expr)(pair._2._2, lh)
            <:> Else)
          (scrutCode <:> caseCodes <:> mkString("Error in match: ") <:> Call("Std_printString")
            <:> Unreachable <:> cases.map(cse => End))

        //   def matchAndBind(pat: Pattern, index: Int = -1): (Code, Map[Identifier, Int]) =
        //     pat match {
              // [scrut pointer] stack
              // load
              // [scrutid] stack
              // push pattern case class id to the stack (Const)
              // [scrutid, patterncaseclassid] stack
              // Eq
              // And matchAndBind(args...) (probably be done outside)
              // map args
        //       case CaseClassPattern(constr, args) => 
        //         {
        //           val caseClassSignature = table.getConstructor(constr).get
        //           val scrutId = lh.getFreshLocal()

        //           val matchNbinds = args.zipWithIndex.foldLeft(List[(Code, Map[Identifier, Int])]()){ case (acc, (arg, index)) 
        //             => {
        //               // TODO put arg on stack and call matchAndBind so that it assumes it is the scrut with right index
        //               val matchNbind = matchAndBind(arg, index=index) // scrut == case class // scrut == scrut case class arg
                      
        //               (Comment("put arg on stack instead of scrut") <:> GetLocal(scrutLocal) <:>
        //           Comment("index is: " + index) <:> 
        //           adtField(index) <:> Load <:> matchNbind._1 <:> And, matchNbind._2) :: acc
        //             }
        //           }

        //           val argsCode = matchNbinds.map(_._1)
        //           val argsBinds = matchNbinds.map(_._2).flatten.toMap
                  
        //           (Comment(pat.toString) <:> Comment("load it's class id") <:>
        //           Comment("class id") <:>
        //           Const(caseClassSignature.index) <:> Eq <:>
        //           argsCode /* <:> "check args"*/, argsBinds)
        //         }
        //     }

        //   Comment(expr.toString) <:> Comment("cg for scrut") <:>
        //   cgExpr(scrut) <:> SetLocal(scrutLocal) <:>
        //   Comment("finished code for scrut") <:>
        //   cases.foldRight(Code(List()))((caze, acc) => {
        //     val matchNbind = matchAndBind(caze.pat)
        //     val condition = matchNbind._1
        //     val matchBind = matchNbind._2
            
        //     Comment(caze.toString) <:>
        //     GetLocal(scrutLocal) <:> condition <:>
        //     If_i32 <:> cgExpr(caze.expr)(locals ++ matchBind, lh) <:>
        //     Else <:> acc}) <:> Unreachable <:>
        //     cases.foldLeft(Code(List()))((acc, _) => acc <:> End)

        case Error(msg) => Comment(expr.toString) <:> cgExpr(msg) <:> Call("Std_printString") <:> Unreachable
        // case _ => { println(expr.toString + " is not implemented"); ??? }
      }
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
