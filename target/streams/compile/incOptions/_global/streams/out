[0m[[0m[0mdebug[0m] [0m[0mCreated transactional ClassFileManager with tempDir = /home/solene/epfl/clp/moocs/gitlab-deploy/lab-empty-handouts/clplab4/target/scala-3.1.3/classes.bak[0m
[0m[[0m[0mdebug[0m] [0m[0mAbout to delete class files:[0m
[0m[[0m[0mdebug[0m] [0m[0mWe backup class files:[0m
[0m[[0m[0mdebug[0m] [0m[0mRegistering generated classes:[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Concat$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Indented.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Concat.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePosition.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitLiteral.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassType.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$KeywordKind.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$ErrorToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	ConstrSig$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Match.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$Constraint$3$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringType$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ModuleDef$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$EOFKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$OperatorKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Sequence.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringLiteral.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$$anon$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$DelimiterToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Plus$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessEquals.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$TypeTree.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$MatchCase.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Minus.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$CommentToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Not$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitType$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringLiteral$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Definition.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Equals.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassDef$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$WildcardPattern$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$And.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	DisplayTokens.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$OS.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Sequence$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$SpaceToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$SpaceToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Indented$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$CommentToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Ite$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Call.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$2.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NoPosition.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanType$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Literal.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKind.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IdPattern.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NoPosition$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Let.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Noop$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolTable.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$BoolLitToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$$anon$2.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$EOFToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Printer.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Neg$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Positioned.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassType$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IdPattern$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Position.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	FunSig.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Type.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Context.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Call$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$KeywordKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lined.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Error$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Mac$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicPrinter.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessEquals$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntLiteral.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Variable$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$$anon$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lined$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Reporter.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IntLitToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Times.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$StringLitToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Token.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ParamDef$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$PrimTypeToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$DelimiterToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$AbstractClassDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$Constraint$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePositioner.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	DisplayTokens$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Ite.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$ErrorToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$IdentifierKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$And$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Neg.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Program$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessThan.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NameAnalyzer$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassPattern$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LiteralPattern.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Error.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ParamDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$MatchCase$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanLiteral$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Linux$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicPrinter$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IdentifierToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Stacked.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Windows$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$PrimTypeKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Tree.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicTreeModule.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Pipeline$$anon$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$AbstractClassDef$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lexer$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntLiteral$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$OperatorToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Match$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	AmycFatalError$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$StringLitToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Or$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$QualifiedName.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$NoKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ModuleDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IdentifierToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$OperatorKind.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Or.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$TypeTree$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessThan$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	ConstrSig.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$LiteralKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Minus$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$QualifiedName$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IntLitToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Equals$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Signature.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Identifier$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Times$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LiteralPattern$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$DelimiterKind.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lexer.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Let$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Raw.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$DelimiterKind$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$BoolLitToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePosition$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Unindented$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$FunDef$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	AmycFatalError.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$FunDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Variable.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassPattern.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	UniqueCounter.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Mod$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Plus.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Noop.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Stacked$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Not.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Document.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Expr.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Div$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$OperatorToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalPrinter$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Mod.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Identifier.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Unindented.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$EOFToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$TypeVariable$3$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Position$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Program.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$KeywordToken.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$TypeVariable$1.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$KeywordToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalPrinter.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanLiteral.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntType$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$WildcardPattern.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Div.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	NameAnalyzer.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Pattern.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitLiteral$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Pipeline.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$PrimTypeToken$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Raw$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	FunSig$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicTreeModule$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassOrFunDef.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Context$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePositioner$.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$3.class[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Concat$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Indented.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Concat.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePosition.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitLiteral.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassType.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$KeywordKind.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$ErrorToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	ConstrSig$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Match.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$Constraint$3$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringType$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ModuleDef$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$EOFKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$OperatorKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Sequence.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringLiteral.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$$anon$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$DelimiterToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Plus$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessEquals.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$TypeTree.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$MatchCase.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Minus.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$CommentToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Not$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitType$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$StringLiteral$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Definition.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Equals.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassDef$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$WildcardPattern$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$And.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	DisplayTokens.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$OS.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Sequence$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$SpaceToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$SpaceToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Indented$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$CommentToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Ite$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Call.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$2.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NoPosition.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanType$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Literal.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKind.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IdPattern.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NoPosition$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Let.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Noop$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolTable.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$BoolLitToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$$anon$2.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$EOFToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Printer.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Neg$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Positioned.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassType$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IdPattern$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Position.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	FunSig.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Type.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Context.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Call$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$KeywordKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lined.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Error$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Mac$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicPrinter.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessEquals$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntLiteral.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Variable$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$$anon$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lined$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Reporter.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IntLitToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Times.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$StringLitToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Token.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ParamDef$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$PrimTypeToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$DelimiterToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$AbstractClassDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$Constraint$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePositioner.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	DisplayTokens$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Ite.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$ErrorToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$IdentifierKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$And$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lab4$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Neg.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Program$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessThan.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NameAnalyzer$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassPattern$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LiteralPattern.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Error.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ParamDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$MatchCase$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanLiteral$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Linux$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicPrinter$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IdentifierToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Stacked.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env$Windows$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$PrimTypeKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Tree.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicTreeModule.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Pipeline$$anon$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$AbstractClassDef$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lexer$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntLiteral$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$OperatorToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Match$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	AmycFatalError$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$StringLitToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Or$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$QualifiedName.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$NoKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ModuleDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IdentifierToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$OperatorKind.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Or.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Env.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$TypeTree$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LessThan$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	ConstrSig.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$LiteralKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Minus$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalTreeModule$QualifiedName$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$IntLitToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Equals$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Signature.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Identifier$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Times$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$LiteralPattern$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$DelimiterKind.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Lexer.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Let$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Raw.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds$DelimiterKind$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$BoolLitToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePosition$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Unindented$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$FunDef$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	AmycFatalError.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$FunDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Variable.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassPattern.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$CaseClassDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	UniqueCounter.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Mod$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Plus.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Noop.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Stacked$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Not.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Document.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Expr.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Div$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$OperatorToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalPrinter$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Mod.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Identifier.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Unindented.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$EOFToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$TypeVariable$3$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Position$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Program.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$KeywordToken.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TypeChecker$TypeVariable$1.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$KeywordToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NominalPrinter.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$BooleanLiteral.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$IntType$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$WildcardPattern.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Div.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	NameAnalyzer.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$Pattern.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$UnitLiteral$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Pipeline.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Tokens$PrimTypeToken$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TokenKinds.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Raw$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	FunSig$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SymbolicTreeModule$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	TreeModule$ClassOrFunDef.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Context$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	SourcePositioner$.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0m	Parser$$anon$3.tasty[0m
[0m[[0m[0mdebug[0m] [0m[0mRemoving the temporary directory used for backing up class files: /home/solene/epfl/clp/moocs/gitlab-deploy/lab-empty-handouts/clplab4/target/scala-3.1.3/classes.bak[0m
